\begin{tikzpicture}[very thick]

\def\NP{$\mathbf{NP}$}
\def\P{$\mathbf{P}$}

\node (OptProblem) [anchor=north west, rectangle,draw] at (0,0) {\begin{minipage}{10cm}\textbf{Definition:} Optimierungsproblem \\Ein Optimierungsproblem ist ein Tupel $O=(I,s,v,t)$ mit 
\begin{align}
 I\subseteq \Sigma^\star \tag{ZulÃ¤ssige Eingaben} \\
S:I\to\mathcal{P}(\Sigma^\star) \tag{ZulÃ¤ssige LÃ¶sungen}\\
v:\{(x,y)| x\in I, y\in S(x) \} \to \mathbb{Q}^+ \tag{Bewertungsfunktion}\\
t\in\{\min,\max\}
\tag{Optimierungstyp}
\end{align}
 \end{minipage} };


\node (OptFunktion) [anchor=north west, rectangle,draw] at (0,-4) {\begin{minipage}{10cm}\textbf{Definition:} Optimate LÃ¶sungsfunktion \\Sei $O=(I,s,v,t)$ ein Optimierungsproblem. Wir definieren $opt$-$v_O$ und $opt_O$ wie folgt:
\begin{align*}opt\text{-}v_O(x) & = \begin{cases} \max\{ v(x,y) | y\in S(x) \}  &, t=\max \\ \min\{ v(x,y) | y\in S(x) \}  &, t=\min  \end{cases}\\
opt_O(X) & =\{ y\in S(x) | v(x,y)=opt\text{-}v_O(x) \}
\end{align*}Eine Funktion $f$ heiÃt optimale LÃ¶sungsfunktion falls\[ \forall x\in I: f(x)\in opt(x) \]
 \end{minipage} };

\node (OptProblem) [anchor=north west, rectangle,draw] at (11,0) {\begin{minipage}{10cm}\textbf{Definition:} \NP-Optimierungsproblem \\
Ein Optimierungsproblem $O=(I,s,v,t)$ ist ein \NP-Optimierungsproblem falls
\begin{align*}
 I\in \mathbf{P}, v\in\mathbf{FP} \\
\exists p\in Poly: \forall x\in I, y\in S(x): |y|\leq p(|x|) \\
\{(x,y)| x\in I, y\in S(x) \}\in\mathbf{P}
\end{align*}
 \end{minipage} };

\node (OptProblem) [anchor=north west, rectangle,draw] at (11,-4) {\begin{minipage}{10cm}\textbf{Definition:} Approximationsalgorithmus \\
Sei  $O=(I,s,v,t)$ ein Optimierungsproblem. Ein Algorithmus $\mathcal{A}$ heiÃt Approximationsalgorithmus fÃ¼r O falls \[\forall x\in I: \mathcal{A}(x)\in S(x)\]
Wie schreiben $v_\mathcal{A}(x)$ fÃ¼r $v(x,\mathcal{A}(x))$
 \end{minipage} };

\node (OptProblem) [anchor=north west, rectangle,draw] at (11,-8) {\begin{minipage}{10cm}\textbf{Definition:} ApproximationsgÃ¼te \\
FÃ¼r ein Optimierungsproblem  $O=(I,s,v,t)$  sei die ApproximationsgÃ¼te $R(x,y)$ der LÃ¶sung $x$ bei Eingabe $y$ wie folgt definiert: \[ R(x,y)=\begin{cases} \frac{opt\text{-}v_O(x)}{v(x,y)} &, t=\max \\ \frac{v(x,y)}{opt\text{-}v_O(x)} &, t=\min \end{cases} \]
 \end{minipage} };

\node (OptProblem) [anchor=north west, rectangle,draw] at (11,-12) {\begin{minipage}{10cm}\textbf{Definition:} $\delta$-Approximationsalgorithmus \\
Sei $\delta:\mathbb{N}\to\mathbb{Q}^+$. Ein Approximationsalgorithmus $\mathcal{A}$ ist ein $\delta$-Appoximationsalgorithmus, falls
\[ \forall x\in I: R(x,\mathcal{A}(x))\leq \delta(|x|)  \]
$\mathcal{A}$ ist ein asymptotischer $\delta$-Approximationsalgorithmus, falls es fÃ¼r jedes $\varepsilon>0$ ein $n_\varepsilon$ gibt, so dass 
\[ \forall x\in I: |x|\geq n_\varepsilon \Rightarrow R(x,\mathcal{A}(x)) \leq \delta(|x|)+\varepsilon \]
 \end{minipage} };


\node (NPO) [anchor=north west, rectangle,draw] at (22,-0) {\begin{minipage}{10cm}\textbf{Klasse:} $\mathbf{NPO}$ \\
Die Klasse aller $\mathbf{NP}$-Optimierungsprobleme.

\textbf{Klasse:} $\mathbf{APX}$ \\
Die Klasse aller $\mathbf{NP}$-Optimierungsprobleme fÃ¼r die ein $c$-Approximationsalgorithmus mit polynomieller Laufzeit existiert (fÃ¼r ein festes $c\geq 1$)

\textbf{Klasse:} $\mathbf{PTAS}$ \\
Die Klasse aller $\mathbf{NP}$-Optimierungsprobleme, die einen Algorithmus $\mathcal{A}$ haben mit:
\begin{align*}
\forall x\in I, \varepsilon>0: R(x,\mathcal{A}(x,\varepsilon))\leq 1+\varepsilon\\
\text{FÃ¼r jedes feste } \varepsilon \text{ hat } \mathcal{A} \text{ polynomielle Laufzeit in } |x| 
\end{align*}

\textbf{Klasse:} $\mathbf{FPTAS}$ \\
Die Klasse aller $\mathbf{PTAS}$ fÃ¼r die $\mathcal{A}$ eine polynomielle Laufzeit in $|x|$ und $1/\varepsilon$ hat.

\textbf{Klasse:} $\mathbf{PO}$ \\
Die Menge aller $\mathbf{NP}$-Optimierungsprobleme, die in polnomieller Zeit lÃ¶sbar sind.
 \end{minipage} };

% \node (APX) [anchor=north west, rectangle,draw] at (22,-2) {\begin{minipage}{10cm}\textbf{Klasse:} $\mathbf{APX}$ \\
% Die Klasse aller $\mathbf{NP}$-Optimierungsprobleme fÃ¼r die ein $c$-Approximationsalgorithmus mit polynomieller Laufzeit existiert (fÃ¼r ein festes $c\geq 1$)
%  \end{minipage} };

% \node (PTAS) [anchor=north west, rectangle,draw] at (22,-5) {\begin{minipage}{10cm}\textbf{Klasse:} $\mathbf{PTAS}$ \\
% Die Klasse aller $\mathbf{NP}$-Optimierungsprobleme, die einen Algorithmus $\mathcal{A}$ haben mit:
% \begin{align*}
% \forall x\in I, \varepsilon>0: R(x,\mathcal{A}(x,\varepsilon))\leq 1+\varepsilon\\
% \text{FÃ¼r jedes feste } \varepsilon \text{ hat } \mathcal{A} \text{ polynomielle Laufzeit in } |x| 
% \end{align*}
%  \end{minipage} };

% \node (FPTAS) [anchor=north west, rectangle,draw] at (22,-8) {\begin{minipage}{10cm}\textbf{Klasse:} $\mathbf{FPTAS}$ \\
% Die Klasse aller $\mathbf{PTAS}$ fÃ¼r die $\mathcal{A}$ eine polynomielle Laufzeit in $|x|$ und $1/\varepsilon$ hat.
%  \end{minipage} };

\node (PO) [anchor=north west, rectangle,draw] at (22,-10) {\begin{minipage}{10cm} \textbf{Definition:} LÃ¼ckenerzeugende Reduktion \\
Sei $L$ eine Sprache, $O=(I,S,v,min)$ ein Optimierungsproblem (fÃ¼r $\max$ analog) und $\rho:\Sigma^\star\to\mathbb{Q}^+$.
Ein $\rho$-LÃ¼ckenerzeugende Reduktion ist ein Tripel $(f,g_+,g_-)$ polynomiller Funktionen mit:
\begin{align*}
f: & \Sigma^\star\to I\\
g_+,g_- : & \Sigma^\star\to\mathbb{Q} \\
\forall x\in\Sigma^\star: & x\in L\Rightarrow opt\text{-}v_O(f(x))\leq g_+(x) \\
& x\notin L\Rightarrow opt\text{-}v_O(f(x))\geq g_-(x)\\ 
& g_-(x)/g_+(x)\geq \rho(x)
\end{align*}
 \end{minipage} };

\node (FPTAS) [anchor=north west, rectangle,draw] at (22,-17) {\begin{minipage}{10cm}\textbf{Satz:}  \\
Sei $O=(I,S,v,min)$ ein \NP-Optimierungsproblem. Desweiteren sie $L$ \NP-vollstÃ¤ndig und $\delta,\rho:\Sigma^\star\to\mathbb{Q}^+$ mit $\rho(x)>\delta(x), \forall x$. Gegeben eine eine $\rho$-lÃ¼ckenerzeugenden Reduktion $(f,g_+,g_-)$ von $L$ auf $O$.
Falls $\mathbf{P}\neq\mathbf{NP}$, dann gibt es keinen $\delta$-Approximationsalgorithmus fÃ¼r $O$.
 \end{minipage} };

\def\myX{2cm}
\def\myY{-13cm}

\node (lerSS) at (\myX,\myY+0.5cm) {$\Sigma^\star$};

\draw (\myX,\myY) -- (\myX,\myY-5cm);

\draw[decorate,decoration={brace,amplitude=10pt}] (\myX,\myY-2.5cm) -- (\myX,\myY) node [midway,xshift=-0.3cm,anchor=east] {$x\in L$};
\draw[decorate,decoration={brace,amplitude=10pt}] (\myX,\myY-5cm) -- (\myX,\myY-2.5cm) node [midway,xshift=-0.3cm,anchor=east] {$x\notin L$};


\node (lerI) at (\myX+2cm,\myY+0.5cm) {$I$};
\draw (\myX+2cm,\myY) -- (\myX+2cm,\myY-5cm);

\draw [<-|] (\myX+2cm,1.25*\myY) -- (\myX+0.1cm,1.25*\myY) node [midway,above] {$f$};
\draw [<-|] (\myX+2cm,1.1*\myY) -- (\myX+0.1cm,1.1*\myY) node [midway,above] {$f$};


\node (lerI) at (\myX+5cm,\myY+0.5cm) {$\mathbb{Q}$};
\draw (\myX+5cm,\myY) -- (\myX+5cm,\myY-5cm);


\draw [->] (\myX+2cm,1.25*\myY) .. controls (\myX+3cm,1.25*\myY) and (\myX+4cm,1.05*\myY)  ..  (\myX+5cm,1.05*\myY) node [right] {\footnotesize$opt(f(x))$};
\draw [->] (\myX+2cm,1.1*\myY) .. controls (\myX+3cm,1.1*\myY) and (\myX+4cm,1.3*\myY)  .. (\myX+5cm,1.3*\myY) node [right] {\footnotesize$opt(f(x))$};

\draw (\myX+2cm,1.25*\myY) [->] -- (\myX+5cm,1.27*\myY) node [midway,above] {\footnotesize$\mathcal{A}(f(x))$};
\draw (\myX+2cm,1.1*\myY) [->] -- (\myX+5cm,1.08*\myY) node [midway,above] {\footnotesize$\mathcal{A}(f(x))$};

\draw [dashed] (\myX+5cm,1.27*\myY) -- (\myX+7cm,1.27*\myY);
\draw [dashed] (\myX+5cm,1.08*\myY) -- (\myX+7cm,1.08*\myY);
\draw[decorate,decoration={brace,amplitude=10pt}] (\myX+7cm,1.08*\myY) -- (\myX+7cm,1.27*\myY) node [midway,xshift=0.3cm,anchor=west] {\footnotesize $\delta$ sized gap};

\draw (\myX+4.9cm,1.22*\myY) -- (\myX+5.1cm,1.22*\myY) node [right] {$g_+(x)$};
\draw (\myX+4.9cm,1.12*\myY) -- (\myX+5.1cm,1.12*\myY) node [right] {$g_-(x)$};

\draw[decorate,decoration={brace,amplitude=10pt}] (\myX+5.1cm,1.12*\myY) -- (\myX+5.1cm,1.22*\myY)  node [midway,xshift=0.3cm,anchor=west] {\footnotesize $\rho$ sized gap};
% \draw[decorate,decoration={brace,amplitude=10pt},xshift=-4pt,yshift=0pt] (0.5,0.5) -- (0.5,5.0) node [black,midway,xshift=-0.6cm] {\footnotesize $P_1$};


\end{tikzpicture}